datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

generator json {
  provider = "prisma-json-types-generator"
}

model User {  
  userId                   String  @unique
  firstName            String
  lastName             String
  /// Institutional email address
  email                String    @unique
  /// Store hashed passwords only
  passwordHash         String
  role                 Role      @default(STUDENT)
  passwordResetToken   String?   @unique
  passwordResetExpires DateTime?
  profileInfo          Json? 
/// Note: Application logic must ensure a user isn't assigned as both Advisor and Evaluator *for the same project*.: string; expertise?: string[]; bio?: string }
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  // --- Relations ---
  advisorRequestsMade  AdvisorRequest[]     @relation("AdvisorRequester") // Requests targeting this user as advisor
  announcementsCreated Announcement[]       @relation("AnnouncementCreator")
  commitsAuthored      Commit[]             @relation("CommitAuthor")
  evaluationsProvided  Evaluation[]         @relation("EvaluationAuthor") // Evaluations written by this user
  feedbackProvided     Feedback[]           @relation("FeedbackAuthor")
  groupsLed            Group[]              @relation("GroupLeader")
  groupsMemberOf       GroupMember[]
  invitesCreated       GroupInvite[]        @relation("InviteCreator")
  mergeRequestsCreated MergeRequest[]       @relation("MergeRequestCreator")
  mergeRequestsReviews MergeRequestReview[] @relation("MergeRequestReviewer")
  notifications        Notification[]       @relation("NotificationRecipient")
  advisedProjects      Project[]            @relation("ProjectAdvisor") // Projects this user advises
  evaluatedProjects    ProjectEvaluator[]   // Projects this user is assigned to evaluate
  tasksAssigned        Task[]               @relation("TaskAssignee")
  tasksCreated         Task[]               @relation("TaskCreator")
  repositoriesOwned    Repository[]         @relation("RepositoryOwner") // Repositories created/managed by this user

  @@index([userId]) // Index for faster username lookups
  @@index([email])    // Index for faster email lookups
}

/// Represents a project group formed by students
model Group {
  id          String   @id @default(cuid())
  groupUserName  String   @unique
  name        String   
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  /// ID of the student who is the group leader
  leaderId        String
  leader          User              @relation("GroupLeader", fields: [leaderId], references: [userId], onDelete: Restrict)
  members         GroupMember[]
  projects        Project[]         @relation("GroupProjects") // A group can have multiple projects
  invites         GroupInvite[]
  advisorRequests AdvisorRequest[] // Requests sent by this group to potential advisors
  repositories    Repository[]      // Repositories owned by this group
  projectRepositories ProjectRepository[] // Join table entries linking projects/repositories for this group

  @@index([name]) // Index for faster group name lookups
}

/// Join table for Group Members (Many-to-Many between User and Group)
model GroupMember {
  groupId  String
  userId   String
  joinedAt DateTime @default(now())

  // --- Relations ---
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@id([groupId, userId])
  @@index([userId])
}

/// Represents a final-year project
model Project {
  id             String        @id @default(cuid())
  title          String
  description    String?
  /// Status of the project using a predefined enum
  status         ProjectStatus @default(ACTIVE)
  isPrivate      Boolean       @default(false)
  submissionDate DateTime?
  archived       Boolean       @default(false)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  groupId        String
  advisorId      String?

  // --- Relations ---
  group             Group              @relation("GroupProjects", fields: [groupId], references: [id], onDelete: Cascade) // UPDATED relation name
  advisor           User?              @relation("ProjectAdvisor", fields: [advisorId], references: [userId], onDelete: SetNull)
  evaluations       Evaluation[]
  feedback          Feedback[]
  projectEvaluators ProjectEvaluator[] // Evaluators assigned to this project
  tasks             Task[]
  repositories      ProjectRepository[] // Many-to-many relation with Repository via join table

  @@index([title])
  @@index([groupId]) // Index for faster lookup by group
  @@index([advisorId])
  @@index([status])
}

/// Join table for Project Evaluators (Many-to-Many between Project and User (Evaluator role))
model ProjectEvaluator {
  projectId   String
  evaluatorId String
  assignedAt  DateTime @default(now())

  // --- Relations ---
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  evaluator User    @relation(fields: [evaluatorId], references: [userId], onDelete: Cascade)

  @@id([projectId, evaluatorId])
  @@index([evaluatorId])
}

model ProjectRepository {
  projectId    String
  repositoryId String
  assignedAt   DateTime @default(now())
  groupId      String   // ID of the group owning both the project and the repository

  // --- Relations ---
  project    Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  repository Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  group      Group      @relation(fields: [groupId], references: [id], onDelete: Cascade) // Explicit link to the owning group

  @@id([projectId, repositoryId])
  @@index([projectId])
  @@index([repositoryId])
  @@index([groupId]) // Index on group for potential filtering
}

/// Represents the Vec repository. Can be owned by a User (groupId=null) or a Group (groupId!=null).
model Repository {
  id        String   @id @default(cuid())
  name      String
  description String
  /// The User who created or primarily manages the repository
  ownerId   String
  isPrivate Boolean  @default(true) // Controls public/private visibility
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  /// ID of the group that owns this repository. If null, it's a user-owned repository.
  groupId   String? // CHANGED: Made optional

  // --- Relations ---
  owner         User              @relation("RepositoryOwner", fields: [ownerId], references: [userId], onDelete: Restrict)
  group         Group?            @relation(fields: [groupId], references: [id], onDelete: Cascade) // CHANGED: Made optional
  branches      Branch[]
  commits       Commit[]
  mergeRequests MergeRequest[]
  remotes       Remote[]
  feedback      Feedback[]
  projects      ProjectRepository[] // Many-to-many relation with Project via join table

  /// Repository names should be unique within their owning group, or among user-owned repos.
  @@unique([name, groupId]) // CHANGED: Unique constraint based on name within the group context
  @@index([name])
  @@index([groupId]) // Index on the optional groupId
  @@index([ownerId]) // Index on the owner
}

/// Represents a commit in the Vec repository
model Commit {
  id              String     @id // Use the actual commit hash as ID
  message         String
  timestamp       DateTime
  createdAt       DateTime   @default(now())
  repositoryId    String
  authorId        String     // User who authored the commit
  parentCommitIDs String[]   // IDs (hashes) of parent commits
  /// ID of the merge request that resulted in this commit (if applicable). This is the foreign key.
  mergeRequestId  String?    @unique

  // --- Relations ---
  repository   Repository    @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  author       User          @relation("CommitAuthor", fields: [authorId], references: [userId], onDelete: Restrict)
  // This side defines the relation details (fields, references, onDelete)
  mergeRequest MergeRequest? @relation("MergeCommit", fields: [mergeRequestId], references: [id], onDelete: SetNull)
  fileChanges  FileChange[]
  branchesHead Branch[]      @relation("BranchHead") // Branches where this commit is the head

  @@index([repositoryId])
  @@index([authorId])
  @@index([timestamp])
  @@index([mergeRequestId]) // Add index for the foreign key
}


/// Represents a file change within a Vec commit
model FileChange {
  id                      String     @id @default(cuid())
  filePath                String
  changeType              ChangeType // ADDED, MODIFIED, DELETED
  fileContentHash         String?    // Hash of the content after the change (null for DELETED)
  previousFileContentHash String?    // Hash of the content before the change (null for ADDED)
  commitId                String     // Commit ID (hash)

  // --- Relations ---
  commit Commit @relation(fields: [commitId], references: [id], onDelete: Cascade)

  @@index([commitId])
  @@index([filePath])
}

/// Represents a branch in the Vec repository
model Branch {
  id           String   @id @default(cuid())
  name         String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  repositoryId String
  headCommitId String   // ID (hash) of the latest commit on this branch

  // --- Relations ---
  repository            Repository     @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  headCommit            Commit         @relation("BranchHead", fields: [headCommitId], references: [id], onDelete: Restrict)
  mergeRequestsAsSource MergeRequest[] @relation("BranchMergeRequestSource") // MRs originating from this branch
  mergeRequestsAsTarget MergeRequest[] @relation("BranchMergeRequestTarget") // MRs targeting this branch

  @@unique([repositoryId, name]) // Branch names must be unique within a repository
  @@index([repositoryId])
}

/// Represents a merge request (like a Pull Request)
model MergeRequest {
  id             String             @id @default(cuid())
  title          String
  description    String?
  status         MergeRequestStatus @default(OPEN)
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  repositoryId   String
  creatorId      String             // User who created the MR
  sourceBranchId String             // Branch changes are coming from
  targetBranchId String             // Branch changes are intended for
  // REMOVED mergedCommitId String? @unique // Removed redundant FK field

  // --- Relations ---
  repository   Repository           @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  creator      User                 @relation("MergeRequestCreator", fields: [creatorId], references: [userId], onDelete: Restrict)
  sourceBranch Branch               @relation("BranchMergeRequestSource", fields: [sourceBranchId], references: [id], onDelete: Cascade)
  targetBranch Branch               @relation("BranchMergeRequestTarget", fields: [targetBranchId], references: [id], onDelete: Cascade)
  reviews      MergeRequestReview[]
  feedback     Feedback[]
  // This side just refers back to the relation defined on Commit.mergeRequest
  mergeCommit  Commit?              @relation("MergeCommit") // REMOVED fields, references, onDelete

  @@index([repositoryId])
  @@index([creatorId])
  @@index([status])
  @@index([sourceBranchId])
  @@index([targetBranchId])
}

/// Represents a review on a merge request (Approval/Rejection/Comments)
model MergeRequestReview {
  id             String         @id @default(cuid())
  decision       ReviewDecision
  comment        String?
  createdAt      DateTime       @default(now())
  mergeRequestId String
  reviewerId     String

  // --- Relations ---
  mergeRequest MergeRequest @relation(fields: [mergeRequestId], references: [id], onDelete: Cascade)
  reviewer     User         @relation("MergeRequestReviewer", fields: [reviewerId], references: [userId], onDelete: Restrict)

  @@index([mergeRequestId])
  @@index([reviewerId])
}

/// Represents a remote repository link for distributed Vec operations
model Remote {
  id           String   @id @default(cuid())
  name         String
  url          String
  createdAt    DateTime @default(now())
  repositoryId String

  // --- Relations ---
  repository Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)

  @@unique([repositoryId, name]) // Remote names unique per repository
  @@index([repositoryId])
}

// -----------------------------------------------------
// Project Management & Communication Models
// -----------------------------------------------------

/// Represents a task within a project
model Task {
  id          String     @id @default(cuid())
  title       String
  description String?
  status      TaskStatus @default(TODO)
  deadline    DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  projectId   String
  assigneeId  String?    // User assigned to the task
  creatorId   String     // User who created the task

  // --- Relations ---
  project  Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  assignee User?   @relation("TaskAssignee", fields: [assigneeId], references: [userId], onDelete: SetNull)
  creator  User    @relation("TaskCreator", fields: [creatorId], references: [userId], onDelete: Restrict)

  @@index([projectId])
  @@index([assigneeId])
  @@index([status])
}

model Feedback {
  id             String         @id @default(cuid())
  title          String?        // Optional title
  content        String
  status         FeedbackStatus @default(OPEN)
  createdAt      DateTime       @default(now())
  authorId       String         // User who gave the feedback
  projectId      String?        // Link if feedback is on a Project
  mergeRequestId String?        // Link if feedback is on a Merge Request
  repositoryId   String?        // Link if feedback is on a Repository

  // --- Relations ---
  author       User         @relation("FeedbackAuthor", fields: [authorId], references: [userId], onDelete: Restrict)
  project      Project?     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  mergeRequest MergeRequest? @relation(fields: [mergeRequestId], references: [id], onDelete: Cascade)
  repository   Repository?  @relation(fields: [repositoryId], references: [id], onDelete: Cascade)

  @@index([authorId])
  @@index([projectId])
  @@index([mergeRequestId])
  @@index([repositoryId])
  // Consider adding a CHECK constraint at the DB level if possible to enforce only one FK is non-null.
}

/// Represents an evaluation submitted for a project
model Evaluation {
  id           String   @id @default(cuid())
  score        Float?   // Overall score (optional)
  comments     String   @db.Text // Detailed comments
  /// Store specific criteria scores/comments as JSON
  criteriaData Json?
  createdAt    DateTime @default(now())
  authorId     String   // User (Evaluator/Advisor role) who submitted the evaluation
  projectId    String

  // --- Relations ---
  author  User    @relation("EvaluationAuthor", fields: [authorId], references: [userId], onDelete: Restrict)
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([authorId])
  @@index([projectId])
}

/// Represents notifications sent to users
model Notification {
  id          String   @id @default(cuid())
  message     String
  read        Boolean  @default(false)
  link        String?  // Optional URL link related to the notification
  createdAt   DateTime @default(now())
  recipientId String

  // --- Relations ---
  recipient User @relation("NotificationRecipient", fields: [recipientId], references: [userId], onDelete: Cascade)

  @@index([recipientId])
  @@index([read])
}

/// Represents a student group's request for an advisor
model AdvisorRequest {
  id                 String               @id @default(cuid())
  status             AdvisorRequestStatus @default(PENDING)
  requestMessage     String?
  responseMessage    String?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  projectId          String               // The project being requested
  groupId            String               // The group making the request
  requestedAdvisorId String               // The User (potential advisor) being requested

  // --- Relations ---
  group            Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  requestedAdvisor User  @relation("AdvisorRequester", fields: [requestedAdvisorId], references: [userId], onDelete: Cascade)

  @@index([groupId])
  @@index([requestedAdvisorId])
  @@index([status])
}

/// Represents an invitation to join a group
model GroupInvite {
  id          String    @id @default(cuid())
  code        String    @unique // Unique code for the invite link
  expiresAt   DateTime
  createdAt   DateTime  @default(now())
  usedAt      DateTime? // Timestamp when the invite was used
  createdById String    // User who created the invite (usually group leader or member)
  groupId     String    // Group the invite is for
  email       String?   // Optionally target a specific email

  // --- Relations ---
  group     Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  createdBy User  @relation("InviteCreator", fields: [createdById], references: [userId], onDelete: Cascade)

  @@index([code])
  @@index([groupId])
  @@index([email]) // If targeted invites are common
  @@index([expiresAt])
}

// -----------------------------------------------------
// System & Configuration Models
// -----------------------------------------------------

/// Represents system-wide announcements created by administrators
model Announcement {
  id        String   @id @default(cuid())
  title     String
  content   String   @db.Text
  active    Boolean  @default(true)
  priority  Int      @default(0) // For ordering announcements
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  creatorId String   // Admin user who created it

  // --- Relations ---
  creator User @relation("AnnouncementCreator", fields: [creatorId], references: [userId], onDelete: Restrict)

  @@index([creatorId])
  @@index([active, createdAt(sort: Desc)]) // Index for fetching active announcements ordered by date
  @@index([priority])
}

/// System-wide rules and configuration settings. Assumed to be a singleton table (only one row).
model Rule {
  id                        Int      @id @default(1) // Fixed ID for singleton
  maxGroupSize              Int      @default(5)
  advisorRequestDeadline    DateTime? // Made optional
  projectSubmissionDeadline DateTime? // Made optional
  updatedAt                 DateTime @updatedAt

  // Add other global settings as needed
}

// -----------------------------------------------------
// Enums
// -----------------------------------------------------

enum Role {
  STUDENT
  ADVISOR
  EVALUATOR
  ADMINISTRATOR
}

enum ProjectStatus {
  ACTIVE      // Project is ongoing
  SUBMITTED   // Project work submitted for evaluation
  COMPLETED   // Evaluation done, project finished
  ARCHIVED    // Project closed and archived
}

enum AdvisorRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum MergeRequestStatus {
  OPEN      // Request is open for review
  APPROVED  // Request has been approved (but not yet merged)
  REJECTED  // Request has been rejected
  MERGED    // Request has been successfully merged
  CLOSED    // Request closed without merging
}

enum ReviewDecision {
  APPROVED          // Reviewer approves the changes
  REJECTED          // Reviewer rejects the changes
  CHANGES_REQUESTED // Reviewer requests specific changes
  COMMENTED         // Reviewer left comments without a specific decision
}

enum ChangeType {
  ADDED
  MODIFIED
  DELETED
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE
  BLOCKED
}

enum FeedbackStatus {
  OPEN      // Feedback requires attention
  ADDRESSED // Feedback has been acknowledged or acted upon
  CLOSED    // Feedback resolution confirmed
}